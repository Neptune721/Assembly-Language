# Assembly-Language
实验7：寻址方式在结构化数据访问中的应用

题目：


<img width="544" alt="1667215281686" src="https://user-images.githubusercontent.com/85387738/198996736-da88c23a-e2db-44ce-895f-babca3441851.png">
<img width="591" alt="1667215302280" src="https://user-images.githubusercontent.com/85387738/198996762-1b01b6f6-f00a-4c66-b042-c346556c73f5.png">

实验思路：根据题目给出的条件可以看出，我们需要将给到我们的数据存入到table的一个数组中，其中我们可以将数组中的每一个元素看作结构体，分别是代表年份的字符串，对应年份的总收入，雇员的人数和需要用除法获取的人均收入，其中table中每一个元素由这四项组成，长为16个字节，所以在将数据载入数组对应元素时，每次只需要向后偏移16位即可实现。比较困难的部分应该是将题目给我们的数据逐个读入，首先我们需要找到每一部分数据对应的偏移地址，通过计算可以得到，年份对应的偏移地址为0-53H，总收入的偏移地址为54H-0A7H，雇员人数的偏移地址为0A8-0D1H，这里需要注意的点是，表示年份的是db型，每一个字符代表一个字节，但因为年份为四位数，所以每一个年份就是占四个字节，总收入为dd型，所以也是占四个字节，但雇员人数是dw型，仅占两个字节，所以这里在计算偏移地址时，将三个均用[bx+idata]的形式来读取就是错误的，因为前两者每次都是偏移四位，所以在这里我的处理是读取三部分数据用到两个寄存器，用[bx+idata]来读取年份和收入，在读取雇员人数的时候用[si+idata]的形式，结合上面的数组元素每次向后偏移16位(用di控制)可以得知，每进行一次循环，bx向后偏移4，si向后偏移2，di向后偏移16.同时在代码的具体实现过程中也会发现在有些地方可以进行代码的优化，在进行年份读入的时候，虽然每一个字符是一个字节，但借助于16位寄存器我们可以一次读入两个字节。在用div指令获得人均收入的时候可以看到被除数都被存在读取总收入时候的ax和dx中，所以我们可以将获得人均收入和获得雇员人数的顺序调换，就可以减少一次对ax和dx的赋值从而提高效率。

4.asm的debug结果：

<img width="319" alt="1667218386745" src="https://user-images.githubusercontent.com/85387738/199005241-c9ccef15-b392-46cf-bd42-385ab9dc2349.png">
